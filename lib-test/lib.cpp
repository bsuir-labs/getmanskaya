//lib.cpp
#include <iostream>
#include "lib.h"

using namespace std;

///
/// \brief buildA Эта функция строит дерево отрезков на основе исходного массива
/// \param t Указатель на дерево отрезков, с которым будем работать
/// \param a Указатель на исходный массив. Дерево отрезков будет строиться для него.
/// \param v Номер вершины дерева, которая будет обрабатываться на текущей итерации.
/// Начинается обработка с первой вершины - т.е. с корня дерева. Подробнее - в lib.h
/// \param tl Левая граница отрезка, за который отвечает вершина v
/// \param tr Правая граница отрезка, за который отвечает вершина v
/// В целом, эти параметры такие же, как и аналогичные у функции kolA.
/// Я там чуть подробнее описал.
/// \return Возвращает указатель на само деревот отрезков
///
tree* buildA(tree* t, int* a, int v, int tl, int tr) {
    if (tl == tr) {                         // если отрезок, за который отвечает
        t->data[v] = a[tl];                 // текущая вершина, содержит в себе только один элемент
        return t;                           // то мы копируем в него элемент из исходного массива на
    }                                       // соответствующей позиции. И выходим из рекурсии назад
    else {                                          // Иначе нам нужно сузить границы - пойти в детей
        int tm = (tl + tr) / 2;                     // Находим середину текущего отрезка
        t = buildA(t, a, 2 * v, tl, tm);            // Идём в левого ребёнка
        t = buildA(t, a, 2 * v + 1, tm + 1, tr);    // И в правого

        /*
         * В целом, рекурсия тут аналогична рекурсии в kolA.
         * Я там более подробно описывал, что происходит, можешь там глянуть.
         */
    }
    return t;
}

///
/// \brief update Это рекурсивная функция, которая изменяет значение элемента
/// с индексом idx
/// \param t Это указатель на дерево, с которым будем работать
/// \param idx Индекс элемента, значение которого нужно переписать
/// \param val Новое значение этого элемента
/// \param v Индекс вершины, которая будет обрабатываться на текущей итерации
/// \param tl Левая граница отрезка, за который отвечает текущая вершина
/// \param tr Правая граница отрезка, за который отвечает текущая вершина
/// \return Указатель на дерево отрезков
///
/// В целом, рекурсия тут опять такая же, как и в kolA
///
tree* update(tree* t, int idx, int val, int v, int tl, int tr) {

    if (idx <= tl && tr <= idx) {       // Если наконец сузились до одного элемента
        t->data[v] = val;               // в отрезке, то присваиваем ему новое значение
        return t;                       // и выходим из рекурсии
    }
    if (tr < idx || idx < tl)           // если текущий отрезок не содержит в себе искомого индекса
        return t;                       // то выходим из рекурсии

    int tm = (tl + tr) / 2;                         // Сужаемся дальше. Находим середину отрезка
    t = update(t, idx, val, v * 2, tl, tm);         // Идём в левого ребёнка
    t = update(t, idx, val, v * 2 + 1, tm + 1, tr); // И в правого. За подробностями - см. ф-цию kolA.
    return t;
}

///
/// \brief kolA Эта функция, которая считает количество вхождений элемента
/// на отрезке. Это, скажем, приватная функция, которую не видно из
/// main.cpp. Оттуда вызывается обёртка над этой функцией с меньшим количеством
/// параметров.
/// \param t Это указатель на дерево отрезков, на котором будет считаться
/// количество вхождений элемента на отрезке
/// \param v Это индекс вершины, которая обрабатывается на текущей итерации.
/// Начинается алгоритм с первой вершины, т.е. с корня дерева. Насчёт индексов -
/// см. коммент в lib.h
/// \param vl Это левая граница отрезка, за который отвечает вершина v. При первом
/// вызове этот параметр равен 0, т.к. корень дерева отвечает за весь исходный массив
/// \param vr Это правая граница отрезка, за который отвечает вершина v. При первом
/// вызове этот параметр равен концу массиве, т.к. корень дерева отвечает за весь
/// исходный массив.
/// \param l Это левая граница отрезка, на котором нам нужно посчитать количество
/// вхождений элемента
/// \param r А это правая граница отрезка, на котором нужно посчитать количество
/// вхождений элемента
/// \param z Ну а это сам элемент, количество вхождений которого нужно посчитать
/// \return Возвращает функция количество вхождений элемента на отрезке от l до r.
///
int kolA(tree* t, int v, int vl, int vr, int l, int r, int z) {
    int p = 0;                  // Это счётчик количества вхождений элемента на
                                // текущем отрезке. На самом деле, тут это
                                // бесполезная переменная, т.к. далее она только
                                // один раз увеличивается на 1 и сразу
                                // возвращается.

    if (r < vl || vr < l)       // Если отрезок, за который отвечает текущая вершина v,
        return 0;               // не пересекается с нужным нам отрезком, то возвращаем 0,
                                // тут считать нечего

    if (vl == vr) {             // Если отрезок, за который отвечает текущая вершина
                                // содержит в себе всего один единственный элемент
        if (t->data[v] == z)    // то мы проверяем, равен ли он искомому элементу
            p++;                // и увеличиваем счётчик, если равен.
        return p;               // и возвращаемся назад, т.к. дальше сужаться некуда.

        /*
         * Я уже писал, что переменная p лишняя.
         * Данный иф можно было написать вот так:
         * if (vl == vr) {
         *     return t->data[v] == z;
         * }
         *
         * Работал бы точно так же.
         * */
    }

    // Ну а если в отрезке больше одного элемента, то мы снова делимся пополам
    // и сужаемся.
    // Сначала находим границы отрезков, за которые будут отвечать дети текущей вершины.
    // Для этого нужно найти середину текущего отрезка.
    // Тогда левый ребёнок будет отвечать за отрезок с границами
    // [vl, vm]
    // А правый:
    // [vm + 1, vr]
    int vm = vl + (vr - vl) / 2;
    int p1 = kolA(t, v * 2, vl, vm, l, r, z);           // И вызываем рекурсивно эту же функцию, но в качестве
    int p2 = kolA(t, v * 2 + 1, vm + 1, vr, l, r, z);   // вершины передаём уже наших детей, и соответственно отрезки,
                                                        // за которые они отвечают. Результат работы функций для детей записываем.
    return p1 + p2;                                     // Складываем результаты детей и возвращаем их как свои.

    /*
     * Почему это дерево бесполезно:
     * В итоге эта функция остановится только когда дойдёт до
     * каждого из листьев.
     * Быстрее просто пройтись по исходному массиву на заданном отрезке и посчитать,
     * чем рекурсивно ходить, как это делается тут.
     */
}

///
/// \brief print Эта функция выводит в консоль массив, в котором лежит
/// дерево отрезков. Описание массива можно найти в lib.h, там большой коммент
/// об этом.
/// \param t Указатель на дерево отрезков, которое нужно вывести
/// \param nMax Количество листьев у дерева отрезков
///
void print(tree* t, int nMax) {
    // Ну и тут просто пробегаемся по всем вершинам в дереве и
    // выводим их по порядку.
    // К слову, т.к. дерево полное бинарное, то всего вершин у него будет
    // как раз в 2 раза больше, чем листьев. (точнее, если у дерева
    // n листьев, то всего вершин будет 2 * n - 1)
    for (int i = 1; i < 2 * nMax; i++)
        cout << t->data[i] << " ";
    cout << endl;
}

///
/// \brief kol Это функция-обёртка над функцией kolA. Нужна просто для того,
/// чтобы из основной программы не нужно было передавать огромное количество
/// непонятных параметров (для работы рекурсивной функции подсчёта необходимо
/// много аргументов, подробное описание которых есть в комментарии над этой
/// самой функции kolA).
/// \param t Это указатель на дерево отрезков
/// \param l Это левая граница интересующего нас отрезка
/// \param r Это правая граница интересующего нас отрезка
/// \param x А это элемент, количество вхождений которого мы ищем
/// \return Возвращает количество вхождений элемента х на отрезке от l до r.
///
int kol(tree* t, int l, int r, int x) {
    return(kolA(t, 1, 0, t->n - 1, l, r, x));
}

///
/// \brief build Это функция для построения дерева отрезков на основе исходных
/// данных. Вообще, она должна просчитывать значения для каждой из вершин
/// дерева отрезков, все дела. В данном же случае, она ничего особо не делает,
/// а просто копирует элементы из исходного массива в свой.
///
/// Это тоже функция-обёртка над приватной функцией, которая описана чуть выше.
/// \param t Это указатель на дерево отрезков, с которым будем работать
/// \param a Это указатель на исходный массив, на основе которого будет
/// строиться дерево отрезков
/// \param n Это размер исходного массива.
/// \return Возвращает указатель на дерево отрезков, переданное как первый аргумент
///
tree* build(tree* t, int* a, int n) {
    t->n = n;
    return(buildA(t, a, 1, 0, t->n - 1));
}

///
/// \brief updRange Функция для изменения значения элементов на определённом
/// отрезке.
/// Функция-обёртка над функцией update (которая изменяет значение конкретного элемента)
/// \param t Указатель на дерево отрезков, с которым будем работать
/// \param new_val Новое значение для элементов
/// \param tl Левая граница отрезка, на котором нужно изменить элементы
/// \param tr Правая граница отрезка, на котором нужно изменить элементы
/// \return Возвращает указатель на дерево отрезков
///
tree* updRange(tree* t, int new_val, int tl, int tr) {
    for (int i = tl; i <= tr; i++)                      // Просто проходимся по каждому элементу из заданного отрезка
        t = update(t, i, new_val, 1, 0, t->n - 1);      // И вызываем для него функцию update, которая заменит его значение
    return (t);
}
