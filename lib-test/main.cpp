#include <iostream>
#include <locale.h>
#include <cmath>
#include "lib.h"

using namespace std;

int main() {
    setlocale(LC_ALL, "russian");

    // Создаётся дерево отрезков
    tree* t = new tree;

    // Создаётся массив для хранения дерева
    t->data = new int[MAX_TREE];

    // Инициализируется нулями
    for (int i = 0; i < MAX_TREE; i++)
        t->data[i] = 0;

    // Тут читаем исходный массив
    int num, new_val, nMax, res, x;
    int n, l, r;
    cout << "Введите размер массива a:\n";
    cin >> n;
    int* a = new int[n];
    cout << "Введите элементы массива а:\n";
    for (int i = 0; i < n; i++)
        cin >> a[i];

    // Это такой хитрый способ получить ближайшую сверху степень двойки.
    // Дело в том, что дерево отрезков хранится в массиве (см. комменты в lib.h),
    // а нам нужно знать размер дерева в этом массиве (т.к. сам массив всегда
    // выделяется на MAX_TREE элементов.
    //
    // Так как дерево отрезков является полным бинарным деревом,
    // то количество его листьев должно быть степенью двойки обязательно.
    // Поэтому, если размер массива "а" не равен степени двойки, нам
    // придётся представить, будто у него всё-таки больше элементов
    // (просто они не будут никак влиять на результат).
    // Так что нужно найти первое число, которое больше либо равно n и является
    // степенью двойки.
    //
    // Для этого берётся бинарный логарифм от размера массива (правда,
    // уменьшенный на 1, для того, чтобы если этот размер уже является
    // степенью двойки, мы не увеличивали ничего больше), к нему прибавляется 1
    // и всё это дело округляется вниз до целого.
    // После чего производится "сдвиг влево" единицы на полученное число. Эта
    // операция сдвигает влево все биты числа. Если она проводится над единицей,
    // то это то же самое, что возвести двойку в какую-либо степень.
    //
    // Пример:
    //
    // Размер массива n = 6
    // log2(6 - 1) = log2(5) = 2.32
    // 2.32 + 1 = 3.32
    // округляем, получается 3
    // 1 << 3 = 2^3 = 8
    // Ближайшая степень двойки сверху к 6 это 8, всё верно.
    nMax = (1 << (int)(log2(1.0*(n - 1)) + 1));


    t = build(t, a, n);
    cout << "Дерево заполнено!" << endl;
    system("pause");

    while (true) {
        system("cls");
        cout << " Выберите действие: ";
        cout << "\n\t1. Просмотр дерева.";
        cout << "\n\t2. Поиск количества вхождений элемента.";
        cout << "\n\t3. Изменение всех чисел на отрезке.";
        cout << "\n\t0. Выход.\n";
        cout << " --> ";
        cin >> num;
        switch (num) {
        case 1:
            print(t, nMax);
            system("pause");
            break;
        case 2:
        {
            cout << "\nМассив а:\n";
            for (int i = 0; i < n; i++)
                cout << a[i] << " ";
            cout << "\n\nВведите элемент: ";
            cin >> x;
            cout << "Задайте отрезок [l..r]:\n";
            cin >> l >> r;
            res = kol(t, l, r, x);
            cout << "Количество вхождений - " << res << endl;
            system("pause");
        }
        break;
        case 3:
        {
            cout << "\nМассив а:\n";
            for (int i = 0; i < n; i++)
                cout << a[i] << " ";
            cout << "\n\n`Задайте отрезок [l..r]:\n";
            cin >> l >> r;
            cout << "\nВведите новое значения:\n";
            cin >> new_val;

            t = updRange(t, new_val, l, r);
            for (int i = l; i <= r; i++)
                a[i] = new_val;
        }
        break;
        case 0:
            return 0;
        }
    }
}
