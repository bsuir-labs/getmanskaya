#ifndef LIB_H
#define LIB_H

const int MAX_TREE = 4096;

// Это структура, где будет храниться дерево отрезков
// (Я так понимаю, вам классы нельзя использовать?)
struct tree {
    int* data,      // data - это массив, где и будет лежать дерево отрезков
         n;         // n - размер исходного массива (в main.cpp это "а")
};

/*
 * Пару слов о том, как можно хранить дерево в массиве.
 * Это легко делается, если дерево у нас бинарное (каждая вершина имеет не
 * более 2 детей) и полное (каждая вершина имеет либо 2, либо 0 потомков)
 * и все листья находятся на одной глубине.
 * Дерево отрезков удовлетворяет этим условиям, так что его можно
 * (и даже удобнее) хранить в массиве.
 *
 * А выглядит это так. Представим какое-нибудь небольшое полное бинарное дерево:
 *  (В скобочках пронумерую каждую вершину для удобства)
 *
 *                 A(1)
 *                / \
 *               /   \
 *              /     \
 *             B(2)    C(3)
 *            / \     / \
 *           D   E   F   G
 *          (4) (5) (6) (7)
 *
 * В лабе про нелинейные списки для каждой вершины дерева создавался свой отдельный
 * объект, у которого были указатели на каждого из детей.
 *
 * В массиве это дерево будет выглядеть как:
 *
 * Индекс   | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
 * ------------------------------------------
 * Значение | 0 | A | B | C | D | E | F | G |
 *
 * Легко заметить, что к каждой вершине мы можем сразу обратиться по индексу,
 * и нам не нужно спускаться до неё от корня дерева, как делали в лабе про деревья.
 *
 * Также, в таком случае мы можем легко получить индекс вершины-предка или детей.
 * Левый ребёнок:  currentIndex * 2
 * Правый ребёнoк: currentIndex * 2 + 1
 * Предок:         currentIndex / 2 (целочисленное деление)
 *
 * Например, если мы сейчас в вершине №3, то наш левый ребёнок
 * лежит под индексом 3 * 2 = 6, правый ребёнок 3 * 2 + 1 = 7,
 * а наш предок в вершине 3 / 2 = 1.
 *
 */


void print(tree* t, int nMax);

//Функция построения дерева отрезков
//t Дерево | a значения отрезка | n кол-во элементов |
tree* build(tree* t, int* a, int n);

//Нахождение вхождений элемента на отрезке
//t Дерево | n кол-во элементов | l - левая нраница отрезка | r - правая граница отрезка | x искомый элемент |
int kol(tree* t, int l, int r, int x);

//Изменение всех значений на отрезке`
//t Дерево | n кол-во элементов | new_val новое значение | tl - левая нраница отрезка | tr - правая граница отрезка |
tree* updRange(tree* t, int new_val, int tl, int tr);


#endif // LIB_H
